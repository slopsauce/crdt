<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRDT Chaos Counter</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #1a1a1a;
            color: #f0f0f0;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .node {
            border: 2px solid #444;
            padding: 20px;
            border-radius: 8px;
            background: #2a2a2a;
            min-width: 200px;
        }
        
        .node-header {
            font-weight: bold;
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .value {
            font-size: 48px;
            margin: 20px 0;
            color: #81c784;
        }
        
        .state {
            font-size: 12px;
            color: #999;
            word-break: break-all;
        }
        
        button {
            background: #4fc3f7;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-family: monospace;
            margin: 5px;
        }
        
        button:hover {
            background: #29b6f6;
        }
        
        .chaos-controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }
        
        .control-section {
            flex: 1;
        }
        
        .chaos-controls label {
            display: inline-block;
            width: 150px;
            margin: 5px 0;
        }
        
        .operation {
            position: absolute;
            background: #ff9800;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.5s ease;
            z-index: 100;
        }
        
        .log {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px;
        }
        
        .log-entry.drop {
            color: #f44336;
            text-decoration: line-through;
        }
        
        .log-entry.delay {
            color: #ff9800;
        }
        
        .log-entry.success {
            color: #81c784;
        }
        
        .partition-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #555;
        }
        
        .partition-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .partition-cell {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .node.partitioned {
            opacity: 0.5;
            border-style: dashed;
        }
        
        .graph-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            height: 200px;
            position: relative;
        }
        
        canvas {
            border: 1px solid #444;
            display: block;
        }
    </style>
</head>
<body>
    <h1>CRDT Chaos Counter Visualizer</h1>
    
    <div class="chaos-controls">
        <div class="control-section">
            <h3>üêµ Chaos Controls</h3>
            <div>
                <label>Drop Rate:</label>
                <input type="range" id="dropRate" min="0" max="100" value="0">
                <span id="dropRateValue">0%</span>
            </div>
            <div>
                <label>Max Delay (ms):</label>
                <input type="range" id="maxDelay" min="0" max="5000" value="0">
                <span id="maxDelayValue">0ms</span>
            </div>
            <div>
                <label>Duplicate Rate:</label>
                <input type="range" id="dupRate" min="0" max="100" value="0">
                <span id="dupRateValue">0%</span>
            </div>
            <div class="partition-controls">
                <h4>Network Partitions</h4>
                <div class="partition-grid">
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionA" onchange="updatePartitions()">
                        <label for="partitionA">Isolate Node A</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionB" onchange="updatePartitions()">
                        <label for="partitionB">Isolate Node B</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionC" onchange="updatePartitions()">
                        <label for="partitionC">Isolate Node C</label>
                    </div>
                </div>
            </div>
        </div>
        <div class="control-section" style="border-left: 1px solid #555; padding-left: 20px;">
            <h3>ü§ñ Auto-Increment</h3>
            <button id="toggleAuto" onclick="toggleAutoIncrement()">Start Auto-Increment</button>
            <div style="margin-top: 10px;">
                <label>Interval (ms):</label>
                <input type="range" id="autoInterval" min="100" max="3000" value="1000">
                <span id="autoIntervalValue">1000ms</span>
            </div>
            <div style="margin-top: 20px;">
                <button onclick="resetAll()" style="background: #f44336;">Reset All</button>
            </div>
        </div>
    </div>
    
    <div class="container" id="nodes"></div>
    
    <div class="graph-container">
        <h3>Convergence Graph</h3>
        <canvas id="convergenceGraph"></canvas>
    </div>
    
    <div class="log" id="log"></div>
    
    <script>
        class GCounter {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.counts = {};
            }
            
            increment() {
                if (!this.counts[this.nodeId]) {
                    this.counts[this.nodeId] = 0;
                }
                this.counts[this.nodeId]++;
                return this;
            }
            
            value() {
                return Object.values(this.counts).reduce((sum, count) => sum + count, 0);
            }
            
            merge(other) {
                const allNodes = new Set([...Object.keys(this.counts), ...Object.keys(other.counts)]);
                for (const node of allNodes) {
                    this.counts[node] = Math.max(this.counts[node] || 0, other.counts[node] || 0);
                }
                return this;
            }
            
            clone() {
                const cloned = new GCounter(this.nodeId);
                cloned.counts = {...this.counts};
                return cloned;
            }
        }
        
        class Node {
            constructor(id, color) {
                this.id = id;
                this.color = color;
                this.counter = new GCounter(id);
                this.element = this.createElement();
                this.updateDisplay();
            }
            
            createElement() {
                const div = document.createElement('div');
                div.className = 'node';
                div.style.borderColor = this.color;
                div.innerHTML = `
                    <div class="node-header" style="color: ${this.color}">Node ${this.id}</div>
                    <div class="value">0</div>
                    <button onclick="incrementNode('${this.id}')">Increment</button>
                    <div class="state"></div>
                `;
                return div;
            }
            
            updateDisplay() {
                this.element.querySelector('.value').textContent = this.counter.value();
                this.element.querySelector('.state').textContent = JSON.stringify(this.counter.counts);
            }
            
            receiveState(state) {
                const oldValue = this.counter.value();
                this.counter.merge(state);
                const newValue = this.counter.value();
                
                if (newValue !== oldValue) {
                    this.element.querySelector('.value').style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        this.element.querySelector('.value').style.transform = 'scale(1)';
                    }, 200);
                }
                
                this.updateDisplay();
            }
        }
        
        const nodes = {};
        const nodeColors = ['#4fc3f7', '#81c784', '#ff9800', '#e91e63'];
        let operationId = 0;
        let autoIncrementIntervals = {};
        let autoIncrementRunning = false;
        const partitions = { A: false, B: false, C: false };
        
        // Graph data
        const graphHistory = { A: [], B: [], C: [] };
        const maxGraphPoints = 100;
        let graphInterval;
        
        function createNodes() {
            const container = document.getElementById('nodes');
            for (let i = 0; i < 3; i++) {
                const node = new Node(String.fromCharCode(65 + i), nodeColors[i]);
                nodes[node.id] = node;
                container.appendChild(node.element);
            }
        }
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function getChaosParams() {
            return {
                dropRate: parseInt(document.getElementById('dropRate').value) / 100,
                maxDelay: parseInt(document.getElementById('maxDelay').value),
                dupRate: parseInt(document.getElementById('dupRate').value) / 100
            };
        }
        
        function propagateOperation(sourceId, state) {
            const chaos = getChaosParams();
            const sourceNode = nodes[sourceId];
            
            // Check if source is partitioned
            if (partitions[sourceId]) {
                log(`Node ${sourceId} is partitioned - operations not propagating`, 'drop');
                return;
            }
            
            Object.keys(nodes).forEach(targetId => {
                if (targetId === sourceId) return;
                
                // Check if target is partitioned
                if (partitions[targetId]) {
                    log(`Node ${targetId} is partitioned - cannot receive from ${sourceId}`, 'drop');
                    return;
                }
                
                const shouldDrop = Math.random() < chaos.dropRate;
                if (shouldDrop) {
                    log(`Operation ${sourceId}‚Üí${targetId} DROPPED`, 'drop');
                    return;
                }
                
                const delay = Math.random() * chaos.maxDelay;
                const shouldDup = Math.random() < chaos.dupRate;
                
                if (delay > 0) {
                    log(`Operation ${sourceId}‚Üí${targetId} delayed by ${Math.round(delay)}ms`, 'delay');
                }
                
                setTimeout(() => {
                    nodes[targetId].receiveState(state);
                    log(`Operation ${sourceId}‚Üí${targetId} delivered`, 'success');
                    
                    if (shouldDup) {
                        const dupDelay = Math.random() * 1000;
                        setTimeout(() => {
                            nodes[targetId].receiveState(state);
                            log(`DUPLICATE: ${sourceId}‚Üí${targetId} delivered again!`, 'delay');
                        }, dupDelay);
                    }
                }, delay);
            });
        }
        
        function incrementNode(nodeId) {
            const node = nodes[nodeId];
            node.counter.increment();
            node.updateDisplay();
            
            log(`Node ${nodeId} incremented locally to ${node.counter.value()}`);
            
            propagateOperation(nodeId, node.counter.clone());
        }
        
        function toggleAutoIncrement() {
            const button = document.getElementById('toggleAuto');
            if (autoIncrementRunning) {
                // Stop auto-increment
                Object.values(autoIncrementIntervals).forEach(interval => clearInterval(interval));
                autoIncrementIntervals = {};
                autoIncrementRunning = false;
                button.textContent = 'Start Auto-Increment';
                log('Auto-increment stopped');
            } else {
                // Start auto-increment
                const interval = parseInt(document.getElementById('autoInterval').value);
                autoIncrementRunning = true;
                button.textContent = 'Stop Auto-Increment';
                
                Object.keys(nodes).forEach((nodeId, index) => {
                    // Schedule increments uniformly distributed across the interval
                    const scheduleNextIncrement = () => {
                        const delay = Math.random() * interval;
                        setTimeout(() => {
                            // Random chance to skip increment for variety
                            if (Math.random() > 0.15) {
                                incrementNode(nodeId);
                            }
                            // Schedule the next one if still running
                            if (autoIncrementRunning) {
                                scheduleNextIncrement();
                            }
                        }, delay);
                    };
                    
                    // Start each node at a random time
                    setTimeout(() => {
                        scheduleNextIncrement();
                    }, Math.random() * interval);
                });
                
                log(`Auto-increment started with ${interval}ms interval`);
            }
        }
        
        function resetAll() {
            // Stop auto-increment if running
            if (autoIncrementRunning) {
                autoIncrementRunning = false;
                document.getElementById('toggleAuto').textContent = 'Start Auto-Increment';
            }
            
            // Reset all nodes
            Object.keys(nodes).forEach(nodeId => {
                nodes[nodeId].counter = new GCounter(nodeId);
                nodes[nodeId].updateDisplay();
            });
            
            // Clear log
            document.getElementById('log').innerHTML = '';
            
            // Reset chaos controls
            document.getElementById('dropRate').value = 0;
            document.getElementById('dropRateValue').textContent = '0%';
            document.getElementById('maxDelay').value = 0;
            document.getElementById('maxDelayValue').textContent = '0ms';
            document.getElementById('dupRate').value = 0;
            document.getElementById('dupRateValue').textContent = '0%';
            
            // Reset partitions
            document.getElementById('partitionA').checked = false;
            document.getElementById('partitionB').checked = false;
            document.getElementById('partitionC').checked = false;
            updatePartitions();
            
            // Clear graph history
            Object.keys(graphHistory).forEach(key => {
                graphHistory[key] = [];
            });
            
            log('All counters and settings reset!');
        }
        
        function updatePartitions() {
            partitions.A = document.getElementById('partitionA').checked;
            partitions.B = document.getElementById('partitionB').checked;
            partitions.C = document.getElementById('partitionC').checked;
            
            Object.keys(nodes).forEach(nodeId => {
                if (partitions[nodeId]) {
                    nodes[nodeId].element.classList.add('partitioned');
                    log(`Node ${nodeId} is now partitioned from the network`);
                } else {
                    nodes[nodeId].element.classList.remove('partitioned');
                }
            });
        }
        
        function initGraph() {
            const canvas = document.getElementById('convergenceGraph');
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth - 40;
            canvas.height = 150;
            
            // Start recording data
            graphInterval = setInterval(updateGraph, 100);
        }
        
        function updateGraph() {
            // Record current values
            Object.keys(nodes).forEach(nodeId => {
                const history = graphHistory[nodeId];
                history.push(nodes[nodeId].counter.value());
                if (history.length > maxGraphPoints) {
                    history.shift();
                }
            });
            
            drawGraph();
        }
        
        function drawGraph() {
            const canvas = document.getElementById('convergenceGraph');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Find max value for scaling
            let maxValue = 1;
            Object.values(graphHistory).forEach(history => {
                history.forEach(val => {
                    if (val > maxValue) maxValue = val;
                });
            });
            
            // Draw grid lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw each node's history
            Object.keys(nodes).forEach((nodeId, index) => {
                const history = graphHistory[nodeId];
                if (history.length < 2) return;
                
                ctx.strokeStyle = nodeColors[index];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                history.forEach((value, i) => {
                    const x = (i / (maxGraphPoints - 1)) * width;
                    const y = height - (value / maxValue) * height * 0.9;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw node label
                ctx.fillStyle = nodeColors[index];
                ctx.font = '12px monospace';
                ctx.fillText(`Node ${nodeId}`, 10, 20 + index * 15);
            });
            
            // Draw convergence indicator
            const values = Object.keys(nodes).map(id => nodes[id].counter.value());
            const allEqual = values.every(v => v === values[0]);
            
            ctx.fillStyle = allEqual ? '#81c784' : '#f44336';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(allEqual ? 'CONVERGED' : 'DIVERGED', width - 100, 20);
        }
        
        window.incrementNode = incrementNode;
        window.toggleAutoIncrement = toggleAutoIncrement;
        window.resetAll = resetAll;
        window.updatePartitions = updatePartitions;
        
        document.getElementById('dropRate').addEventListener('input', (e) => {
            document.getElementById('dropRateValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('maxDelay').addEventListener('input', (e) => {
            document.getElementById('maxDelayValue').textContent = e.target.value + 'ms';
        });
        
        document.getElementById('dupRate').addEventListener('input', (e) => {
            document.getElementById('dupRateValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('autoInterval').addEventListener('input', (e) => {
            document.getElementById('autoIntervalValue').textContent = e.target.value + 'ms';
            // If running, restart with new interval
            if (autoIncrementRunning) {
                toggleAutoIncrement(); // Stop
                toggleAutoIncrement(); // Start with new interval
            }
        });
        
        createNodes();
        initGraph();
        log('Chaos Counter initialized. Click increment buttons and adjust chaos controls!');
    </script>
</body>
</html>