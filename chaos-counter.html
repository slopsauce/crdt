<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRDT Chaos Counter</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #1a1a1a;
            color: #f0f0f0;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .node {
            border: 2px solid #444;
            padding: 20px;
            border-radius: 8px;
            background: #2a2a2a;
            min-width: 200px;
            position: relative;
        }
        
        .node.child::before {
            content: "‚Üñ";
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            color: #666;
        }
        
        .node-header {
            font-weight: bold;
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .value {
            font-size: 48px;
            margin: 20px 0;
            color: #81c784;
        }
        
        .state {
            font-size: 12px;
            color: #999;
            word-break: break-all;
        }
        
        button {
            background: #4fc3f7;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-family: monospace;
            margin: 5px;
        }
        
        button:hover {
            background: #29b6f6;
        }
        
        .chaos-controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }
        
        .control-section {
            flex: 1;
        }
        
        .chaos-controls label {
            display: inline-block;
            width: 150px;
            margin: 5px 0;
        }
        
        .operation {
            position: absolute;
            background: #ff9800;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.5s ease;
            z-index: 100;
        }
        
        .log {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px;
        }
        
        .log-entry.drop {
            color: #f44336;
            text-decoration: line-through;
        }
        
        .log-entry.delay {
            color: #ff9800;
        }
        
        .log-entry.success {
            color: #81c784;
        }
        
        .partition-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #555;
        }
        
        .partition-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .partition-cell {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .node.partitioned {
            opacity: 0.5;
            border-style: dashed;
        }
        
        .graph-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            height: 200px;
            position: relative;
        }
        
        canvas {
            border: 1px solid #444;
            display: block;
        }
    </style>
</head>
<body>
    <h1>CRDT Chaos Counter Visualizer</h1>
    
    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-family: monospace;">
        <strong>Network Topology:</strong> 
        <span style="color: #4fc3f7;">A</span> ‚Üî 
        <span style="color: #81c784;">B</span> ‚Üî 
        <span style="color: #ff9800;">C</span> ‚Üí 
        <span style="color: #e91e63;">D</span>, 
        <span style="color: #9c27b0;">E</span>
        <br>
        <small style="color: #999;">D and E can only communicate through C</small>
    </div>
    
    <div class="chaos-controls">
        <div class="control-section">
            <h3>üêµ Chaos Controls</h3>
            <div>
                <label>Drop Rate:</label>
                <input type="range" id="dropRate" min="0" max="100" value="0">
                <span id="dropRateValue">0%</span>
            </div>
            <div>
                <label>Max Delay (ms):</label>
                <input type="range" id="maxDelay" min="0" max="5000" value="0">
                <span id="maxDelayValue">0ms</span>
            </div>
            <div>
                <label>Duplicate Rate:</label>
                <input type="range" id="dupRate" min="0" max="100" value="0">
                <span id="dupRateValue">0%</span>
            </div>
            <div class="partition-controls">
                <h4>Network Partitions</h4>
                <div class="partition-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionA" onchange="updatePartitions()">
                        <label for="partitionA">Isolate Node A</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionB" onchange="updatePartitions()">
                        <label for="partitionB">Isolate Node B</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionC" onchange="updatePartitions()">
                        <label for="partitionC">Isolate Node C</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionD" onchange="updatePartitions()">
                        <label for="partitionD">Isolate Node D</label>
                    </div>
                    <div class="partition-cell">
                        <input type="checkbox" id="partitionE" onchange="updatePartitions()">
                        <label for="partitionE">Isolate Node E</label>
                    </div>
                </div>
            </div>
        </div>
        <div class="control-section" style="border-left: 1px solid #555; padding-left: 20px;">
            <h3>ü§ñ Auto-Increment</h3>
            <button id="toggleAuto" onclick="toggleAutoIncrement()">Start Auto-Increment</button>
            <div style="margin-top: 10px;">
                <label>Interval (ms):</label>
                <input type="range" id="autoInterval" min="100" max="3000" value="1000">
                <span id="autoIntervalValue">1000ms</span>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #555;">
                <h4>üó£Ô∏è Gossip Protocol</h4>
                <button id="toggleGossip" onclick="toggleGossip()">Enable Gossip Mode</button>
                <div style="margin-top: 10px;">
                    <label>Gossip Interval (ms):</label>
                    <input type="range" id="gossipInterval" min="1000" max="10000" value="3000">
                    <span id="gossipIntervalValue">3000ms</span>
                </div>
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    Nodes randomly sync with peers, bypassing topology
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button onclick="resetAll()" style="background: #f44336;">Reset All</button>
            </div>
            <div style="margin-top: 10px;">
                <button id="toggleChaosMonkey" onclick="toggleChaosMonkey()" style="background: #9c27b0;">üêµ Unleash Chaos Monkey</button>
            </div>
        </div>
    </div>
    
    <div class="container" id="nodes"></div>
    
    <div class="graph-container">
        <h3>Convergence Graph</h3>
        <canvas id="convergenceGraph"></canvas>
    </div>
    
    <div class="log" id="log"></div>
    
    <script>
        class GCounter {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.counts = {};
            }
            
            increment() {
                if (!this.counts[this.nodeId]) {
                    this.counts[this.nodeId] = 0;
                }
                this.counts[this.nodeId]++;
                return this;
            }
            
            value() {
                return Object.values(this.counts).reduce((sum, count) => sum + count, 0);
            }
            
            merge(other) {
                const allNodes = new Set([...Object.keys(this.counts), ...Object.keys(other.counts)]);
                for (const node of allNodes) {
                    this.counts[node] = Math.max(this.counts[node] || 0, other.counts[node] || 0);
                }
                return this;
            }
            
            clone() {
                const cloned = new GCounter(this.nodeId);
                cloned.counts = {...this.counts};
                return cloned;
            }
        }
        
        class Node {
            constructor(id, color) {
                this.id = id;
                this.color = color;
                this.counter = new GCounter(id);
                this.element = this.createElement();
                this.updateDisplay();
            }
            
            createElement() {
                const div = document.createElement('div');
                div.className = 'node';
                div.style.borderColor = this.color;
                div.innerHTML = `
                    <div class="node-header" style="color: ${this.color}">Node ${this.id}</div>
                    <div class="value">0</div>
                    <button onclick="incrementNode('${this.id}')">Increment</button>
                    <div class="state"></div>
                `;
                return div;
            }
            
            updateDisplay() {
                this.element.querySelector('.value').textContent = this.counter.value();
                this.element.querySelector('.state').textContent = JSON.stringify(this.counter.counts);
            }
            
            receiveState(state) {
                const oldValue = this.counter.value();
                this.counter.merge(state);
                const newValue = this.counter.value();
                
                if (newValue !== oldValue) {
                    this.element.querySelector('.value').style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        this.element.querySelector('.value').style.transform = 'scale(1)';
                    }, 200);
                }
                
                this.updateDisplay();
            }
        }
        
        const nodes = {};
        const nodeColors = ['#4fc3f7', '#81c784', '#ff9800', '#e91e63', '#9c27b0'];
        let operationId = 0;
        let autoIncrementIntervals = {};
        let autoIncrementRunning = false;
        const partitions = { A: false, B: false, C: false, D: false, E: false };
        let chaosMonkeyInterval = null;
        let gossipIntervals = {};
        let gossipRunning = false;
        
        // Define network topology - who can talk to whom
        const networkTopology = {
            A: ['B', 'C'],
            B: ['A', 'C'],
            C: ['A', 'B', 'D', 'E'],
            D: ['C'],
            E: ['C']
        };
        
        // Graph data
        const graphHistory = { A: [], B: [], C: [], D: [], E: [] };
        const maxGraphPoints = 100;
        let graphInterval;
        
        function createNodes() {
            const container = document.getElementById('nodes');
            // Create all 5 nodes
            for (let i = 0; i < 5; i++) {
                const node = new Node(String.fromCharCode(65 + i), nodeColors[i]);
                nodes[node.id] = node;
                container.appendChild(node.element);
            }
            
            // Style D and E as child nodes with visual indicators
            nodes.D.element.style.marginLeft = '50px';
            nodes.E.element.style.marginLeft = '50px';
            nodes.D.element.classList.add('child');
            nodes.E.element.classList.add('child');
            
            // Add topology info to node headers
            nodes.A.element.querySelector('.node-header').innerHTML = 'Node A <span style="font-size:12px;color:#666;">(connects to B,C)</span>';
            nodes.B.element.querySelector('.node-header').innerHTML = 'Node B <span style="font-size:12px;color:#666;">(connects to A,C)</span>';
            nodes.C.element.querySelector('.node-header').innerHTML = 'Node C <span style="font-size:12px;color:#666;">(hub: A,B,D,E)</span>';
            nodes.D.element.querySelector('.node-header').innerHTML = 'Node D <span style="font-size:12px;color:#666;">(child of C)</span>';
            nodes.E.element.querySelector('.node-header').innerHTML = 'Node E <span style="font-size:12px;color:#666;">(child of C)</span>';
        }
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            
            // Keep only the last 100 log entries to prevent memory bloat
            while (logDiv.children.length > 100) {
                logDiv.removeChild(logDiv.firstChild);
            }
            
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function getChaosParams() {
            return {
                dropRate: parseInt(document.getElementById('dropRate').value) / 100,
                maxDelay: parseInt(document.getElementById('maxDelay').value),
                dupRate: parseInt(document.getElementById('dupRate').value) / 100
            };
        }
        
        function propagateOperation(sourceId, state) {
            const chaos = getChaosParams();
            const sourceNode = nodes[sourceId];
            
            // Check if source is partitioned
            if (partitions[sourceId]) {
                log(`Node ${sourceId} is partitioned - operations not propagating`, 'drop');
                return;
            }
            
            // Only propagate to nodes that are connected in the topology
            const connectedNodes = networkTopology[sourceId];
            connectedNodes.forEach(targetId => {
                // Check if target is partitioned
                if (partitions[targetId]) {
                    log(`Node ${targetId} is partitioned - cannot receive from ${sourceId}`, 'drop');
                    return;
                }
                
                const shouldDrop = Math.random() < chaos.dropRate;
                if (shouldDrop) {
                    log(`Operation ${sourceId}‚Üí${targetId} DROPPED`, 'drop');
                    return;
                }
                
                const delay = Math.random() * chaos.maxDelay;
                const shouldDup = Math.random() < chaos.dupRate;
                
                if (delay > 0) {
                    log(`Operation ${sourceId}‚Üí${targetId} delayed by ${Math.round(delay)}ms`, 'delay');
                }
                
                setTimeout(() => {
                    nodes[targetId].receiveState(state);
                    log(`Operation ${sourceId}‚Üí${targetId} delivered`, 'success');
                    
                    if (shouldDup) {
                        const dupDelay = Math.random() * 1000;
                        setTimeout(() => {
                            nodes[targetId].receiveState(state);
                            log(`DUPLICATE: ${sourceId}‚Üí${targetId} delivered again!`, 'delay');
                        }, dupDelay);
                    }
                }, delay);
            });
        }
        
        function incrementNode(nodeId) {
            const node = nodes[nodeId];
            node.counter.increment();
            node.updateDisplay();
            
            log(`Node ${nodeId} incremented locally to ${node.counter.value()}`);
            
            propagateOperation(nodeId, node.counter.clone());
        }
        
        function toggleAutoIncrement() {
            const button = document.getElementById('toggleAuto');
            if (autoIncrementRunning) {
                // Stop auto-increment
                Object.values(autoIncrementIntervals).forEach(interval => clearInterval(interval));
                autoIncrementIntervals = {};
                autoIncrementRunning = false;
                button.textContent = 'Start Auto-Increment';
                log('Auto-increment stopped');
            } else {
                // Start auto-increment
                const interval = parseInt(document.getElementById('autoInterval').value);
                autoIncrementRunning = true;
                button.textContent = 'Stop Auto-Increment';
                
                Object.keys(nodes).forEach((nodeId, index) => {
                    // Schedule increments uniformly distributed across the interval
                    const scheduleNextIncrement = () => {
                        const delay = Math.random() * interval;
                        setTimeout(() => {
                            // Random chance to skip increment for variety
                            if (Math.random() > 0.15) {
                                incrementNode(nodeId);
                            }
                            // Schedule the next one if still running
                            if (autoIncrementRunning) {
                                scheduleNextIncrement();
                            }
                        }, delay);
                    };
                    
                    // Start each node at a random time
                    setTimeout(() => {
                        scheduleNextIncrement();
                    }, Math.random() * interval);
                });
                
                log(`Auto-increment started with ${interval}ms interval`);
            }
        }
        
        function resetAll() {
            // Stop auto-increment if running
            if (autoIncrementRunning) {
                autoIncrementRunning = false;
                document.getElementById('toggleAuto').textContent = 'Start Auto-Increment';
            }
            
            // Stop chaos monkey if running
            if (chaosMonkeyInterval) {
                clearTimeout(chaosMonkeyInterval);
                chaosMonkeyInterval = null;
                document.getElementById('toggleChaosMonkey').textContent = 'üêµ Unleash Chaos Monkey';
                document.getElementById('toggleChaosMonkey').style.background = '#9c27b0';
            }
            
            // Stop gossip if running
            if (gossipRunning) {
                Object.values(gossipIntervals).forEach(interval => clearTimeout(interval));
                gossipIntervals = {};
                gossipRunning = false;
                document.getElementById('toggleGossip').textContent = 'Enable Gossip Mode';
                document.getElementById('toggleGossip').style.background = '#4fc3f7';
            }
            
            // Reset all nodes
            Object.keys(nodes).forEach(nodeId => {
                nodes[nodeId].counter = new GCounter(nodeId);
                nodes[nodeId].updateDisplay();
            });
            
            // Clear log
            document.getElementById('log').innerHTML = '';
            
            // Reset chaos controls
            document.getElementById('dropRate').value = 0;
            document.getElementById('dropRateValue').textContent = '0%';
            document.getElementById('maxDelay').value = 0;
            document.getElementById('maxDelayValue').textContent = '0ms';
            document.getElementById('dupRate').value = 0;
            document.getElementById('dupRateValue').textContent = '0%';
            
            // Reset partitions
            Object.keys(partitions).forEach(nodeId => {
                document.getElementById(`partition${nodeId}`).checked = false;
            });
            updatePartitions();
            
            // Clear graph history
            Object.keys(graphHistory).forEach(key => {
                graphHistory[key] = [];
            });
            
            log('All counters and settings reset!');
        }
        
        function updatePartitions() {
            Object.keys(partitions).forEach(nodeId => {
                partitions[nodeId] = document.getElementById(`partition${nodeId}`).checked;
                
                if (partitions[nodeId]) {
                    nodes[nodeId].element.classList.add('partitioned');
                    log(`Node ${nodeId} is now partitioned from the network`);
                } else {
                    nodes[nodeId].element.classList.remove('partitioned');
                }
            });
        }
        
        function initGraph() {
            const canvas = document.getElementById('convergenceGraph');
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth - 40;
            canvas.height = 150;
            
            // Start recording data
            graphInterval = setInterval(updateGraph, 100);
        }
        
        function updateGraph() {
            // Record current values
            Object.keys(nodes).forEach(nodeId => {
                const history = graphHistory[nodeId];
                history.push(nodes[nodeId].counter.value());
                if (history.length > maxGraphPoints) {
                    history.shift();
                }
            });
            
            drawGraph();
        }
        
        function drawGraph() {
            const canvas = document.getElementById('convergenceGraph');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Find max value for scaling
            let maxValue = 1;
            Object.values(graphHistory).forEach(history => {
                history.forEach(val => {
                    if (val > maxValue) maxValue = val;
                });
            });
            
            // Draw grid lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw each node's history
            Object.keys(nodes).forEach((nodeId, index) => {
                const history = graphHistory[nodeId];
                if (history.length < 2) return;
                
                ctx.strokeStyle = nodeColors[index];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                history.forEach((value, i) => {
                    const x = (i / (maxGraphPoints - 1)) * width;
                    const y = height - (value / maxValue) * height * 0.9;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw node label
                ctx.fillStyle = nodeColors[index];
                ctx.font = '12px monospace';
                ctx.fillText(`Node ${nodeId}`, 10, 20 + index * 15);
            });
            
            // Draw convergence indicator
            const values = Object.keys(nodes).map(id => nodes[id].counter.value());
            const allEqual = values.every(v => v === values[0]);
            
            ctx.fillStyle = allEqual ? '#81c784' : '#f44336';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(allEqual ? 'CONVERGED' : 'DIVERGED', width - 100, 20);
        }
        
        function toggleChaosMonkey() {
            const button = document.getElementById('toggleChaosMonkey');
            
            if (chaosMonkeyInterval) {
                // Stop the chaos
                clearInterval(chaosMonkeyInterval);
                chaosMonkeyInterval = null;
                button.textContent = 'üêµ Unleash Chaos Monkey';
                button.style.background = '#9c27b0';
                log('Chaos Monkey has been caged! üîí', 'success');
            } else {
                // UNLEASH THE CHAOS!
                button.textContent = 'üôà Stop the Madness!';
                button.style.background = '#e91e63';
                log('CHAOS MONKEY UNLEASHED! üêµüí• Randomizing all parameters every 2-5 seconds!', 'drop');
                
                const randomizeChaos = () => {
                    // Random drop rate (0-100%)
                    const dropRate = Math.floor(Math.random() * 101);
                    document.getElementById('dropRate').value = dropRate;
                    document.getElementById('dropRateValue').textContent = dropRate + '%';
                    
                    // Random delay (0-5000ms)
                    const maxDelay = Math.floor(Math.random() * 5001);
                    document.getElementById('maxDelay').value = maxDelay;
                    document.getElementById('maxDelayValue').textContent = maxDelay + 'ms';
                    
                    // Random duplicate rate (0-100%)
                    const dupRate = Math.floor(Math.random() * 101);
                    document.getElementById('dupRate').value = dupRate;
                    document.getElementById('dupRateValue').textContent = dupRate + '%';
                    
                    // Randomly partition nodes (30% chance each)
                    const nodeList = ['A', 'B', 'C', 'D', 'E'];
                    nodeList.forEach(node => {
                        const shouldPartition = Math.random() < 0.3;
                        document.getElementById(`partition${node}`).checked = shouldPartition;
                    });
                    updatePartitions();
                    
                    // Random auto-increment interval if running
                    if (autoIncrementRunning) {
                        const interval = Math.floor(Math.random() * 2900) + 100;
                        document.getElementById('autoInterval').value = interval;
                        document.getElementById('autoIntervalValue').textContent = interval + 'ms';
                        // Restart with new interval
                        toggleAutoIncrement();
                        toggleAutoIncrement();
                    }
                    
                    log(`üêµ CHAOS CHANGE: Drop=${dropRate}%, Delay=${maxDelay}ms, Dup=${dupRate}%`, 'delay');
                };
                
                // Initial chaos
                randomizeChaos();
                
                // Keep changing chaos every 2-5 seconds
                const scheduleNextChaos = () => {
                    const delay = Math.random() * 3000 + 2000; // 2-5 seconds
                    chaosMonkeyInterval = setTimeout(() => {
                        if (chaosMonkeyInterval) {
                            randomizeChaos();
                            scheduleNextChaos();
                        }
                    }, delay);
                };
                scheduleNextChaos();
            }
        }
        
        function gossipSync(sourceId) {
            if (partitions[sourceId]) {
                return; // Partitioned nodes can't gossip
            }
            
            // Get all other non-partitioned nodes
            const availableNodes = Object.keys(nodes).filter(id => 
                id !== sourceId && !partitions[id]
            );
            
            if (availableNodes.length === 0) {
                return; // No one to gossip with
            }
            
            // Pick random target
            const targetId = availableNodes[Math.floor(Math.random() * availableNodes.length)];
            
            // Exchange states (bi-directional sync)
            const sourceState = nodes[sourceId].counter.clone();
            const targetState = nodes[targetId].counter.clone();
            
            log(`üó£Ô∏è GOSSIP: ${sourceId} ‚Üî ${targetId} exchanging states`, 'delay');
            
            // Both nodes merge each other's state
            nodes[sourceId].receiveState(targetState);
            nodes[targetId].receiveState(sourceState);
        }
        
        function toggleGossip() {
            const button = document.getElementById('toggleGossip');
            
            if (gossipRunning) {
                // Stop gossip
                Object.values(gossipIntervals).forEach(interval => clearInterval(interval));
                gossipIntervals = {};
                gossipRunning = false;
                button.textContent = 'Enable Gossip Mode';
                button.style.background = '#4fc3f7';
                log('üó£Ô∏è Gossip protocol disabled', 'success');
            } else {
                // Start gossip
                const interval = parseInt(document.getElementById('gossipInterval').value);
                gossipRunning = true;
                button.textContent = 'Disable Gossip Mode';
                button.style.background = '#ff9800';
                log(`üó£Ô∏è Gossip protocol enabled! Nodes will randomly sync every ${interval}ms`, 'success');
                
                // Each node gossips independently with random intervals
                Object.keys(nodes).forEach((nodeId, index) => {
                    const scheduleNextGossip = () => {
                        const delay = interval + (Math.random() - 0.5) * interval * 0.4; // ¬±20% variance
                        gossipIntervals[nodeId] = setTimeout(() => {
                            if (gossipRunning) {
                                gossipSync(nodeId);
                                scheduleNextGossip();
                            }
                        }, delay);
                    };
                    
                    // Stagger initial gossip to avoid synchronized storms
                    setTimeout(() => {
                        scheduleNextGossip();
                    }, Math.random() * interval);
                });
            }
        }
        
        window.incrementNode = incrementNode;
        window.toggleAutoIncrement = toggleAutoIncrement;
        window.resetAll = resetAll;
        window.updatePartitions = updatePartitions;
        window.toggleChaosMonkey = toggleChaosMonkey;
        window.toggleGossip = toggleGossip;
        
        document.getElementById('dropRate').addEventListener('input', (e) => {
            document.getElementById('dropRateValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('maxDelay').addEventListener('input', (e) => {
            document.getElementById('maxDelayValue').textContent = e.target.value + 'ms';
        });
        
        document.getElementById('dupRate').addEventListener('input', (e) => {
            document.getElementById('dupRateValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('autoInterval').addEventListener('input', (e) => {
            document.getElementById('autoIntervalValue').textContent = e.target.value + 'ms';
            // If running, restart with new interval
            if (autoIncrementRunning) {
                toggleAutoIncrement(); // Stop
                toggleAutoIncrement(); // Start with new interval
            }
        });
        
        document.getElementById('gossipInterval').addEventListener('input', (e) => {
            document.getElementById('gossipIntervalValue').textContent = e.target.value + 'ms';
            // If running, restart with new interval
            if (gossipRunning) {
                toggleGossip(); // Stop
                toggleGossip(); // Start with new interval
            }
        });
        
        createNodes();
        initGraph();
        log('Chaos Counter initialized. Click increment buttons and adjust chaos controls!');
    </script>
</body>
</html>